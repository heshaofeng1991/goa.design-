// Code generated by goa v3.6.2, DO NOT EDIT.
//
// product HTTP client encoders and decoders
//
// Command:
// $ goa gen goa/design -o ./

package client

import (
	"bytes"
	"context"
	"fmt"
	product "goa/gen/product"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildBatchesCreateProductRequest instantiates a HTTP request object with
// method and path set to call the "product" service "batches_create_product"
// endpoint
func (c *Client) BuildBatchesCreateProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: BatchesCreateProductProductPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "batches_create_product", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeBatchesCreateProductRequest returns an encoder for requests sent to
// the product batches_create_product server.
func EncodeBatchesCreateProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.MultiProduct)
		if !ok {
			return goahttp.ErrInvalidType("product", "batches_create_product", "*product.MultiProduct", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewBatchesCreateProductRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("product", "batches_create_product", err)
		}
		return nil
	}
}

// DecodeBatchesCreateProductResponse returns a decoder for responses returned
// by the product batches_create_product endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeBatchesCreateProductResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- error: internal error
func DecodeBatchesCreateProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body BatchesCreateProductResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "batches_create_product", err)
			}
			err = ValidateBatchesCreateProductResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "batches_create_product", err)
			}
			res := NewBatchesCreateProductMultiProductRspOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body BatchesCreateProductUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "batches_create_product", err)
			}
			err = ValidateBatchesCreateProductUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "batches_create_product", err)
			}
			return nil, NewBatchesCreateProductUnauthorized(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "batches_create_product", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "update_product" endpoint
func (c *Client) BuildUpdateProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateProductProductPath()}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "update_product", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateProductRequest returns an encoder for requests sent to the
// product update_product server.
func EncodeUpdateProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.Product)
		if !ok {
			return goahttp.ErrInvalidType("product", "update_product", "*product.Product", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewUpdateProductRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("product", "update_product", err)
		}
		return nil
	}
}

// DecodeUpdateProductResponse returns a decoder for responses returned by the
// product update_product endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeUpdateProductResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- error: internal error
func DecodeUpdateProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateProductResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "update_product", err)
			}
			err = ValidateUpdateProductResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "update_product", err)
			}
			res := NewUpdateProductUpdateResponseOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body UpdateProductUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "update_product", err)
			}
			err = ValidateUpdateProductUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "update_product", err)
			}
			return nil, NewUpdateProductUnauthorized(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "update_product", resp.StatusCode, string(body))
		}
	}
}

// BuildExportProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "export_product" endpoint
func (c *Client) BuildExportProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ExportProductProductPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "export_product", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeExportProductRequest returns an encoder for requests sent to the
// product export_product server.
func EncodeExportProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.ProductQueryPayload)
		if !ok {
			return goahttp.ErrInvalidType("product", "export_product", "*product.ProductQueryPayload", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		for _, value := range p.ID {
			values.Add("id", value)
		}
		if p.Sku != nil {
			values.Add("sku", *p.Sku)
		}
		if p.Barcode != nil {
			values.Add("barcode", *p.Barcode)
		}
		if p.Status != nil {
			values.Add("status", *p.Status)
		}
		for _, value := range p.Attributes {
			values.Add("attributes", value)
		}
		if p.Name != nil {
			values.Add("name", *p.Name)
		}
		if p.Inventory != nil {
			values.Add("inventory", *p.Inventory)
		}
		if p.Current != nil {
			values.Add("current", fmt.Sprintf("%v", *p.Current))
		}
		if p.PageSize != nil {
			values.Add("page_size", fmt.Sprintf("%v", *p.PageSize))
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeExportProductResponse returns a decoder for responses returned by the
// product export_product endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeExportProductResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "internal_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeExportProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				length int64
				err    error
			)
			{
				lengthRaw := resp.Header.Get("Content-Length")
				if lengthRaw == "" {
					return nil, goahttp.ErrValidationError("product", "export_product", goa.MissingFieldError("Content-Length", "header"))
				}
				v, err2 := strconv.ParseInt(lengthRaw, 10, 64)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("length", lengthRaw, "integer"))
				}
				length = v
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "export_product", err)
			}
			res := NewExportProductResultOK(length)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body ExportProductUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "export_product", err)
			}
			err = ValidateExportProductUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "export_product", err)
			}
			return nil, NewExportProductUnauthorized(&body)
		case http.StatusInternalServerError:
			var (
				body ExportProductInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "export_product", err)
			}
			err = ValidateExportProductInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "export_product", err)
			}
			return nil, NewExportProductInternalError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "export_product", resp.StatusCode, string(body))
		}
	}
}

// BuildDownloadTemplatesRequest instantiates a HTTP request object with method
// and path set to call the "product" service "download_templates" endpoint
func (c *Client) BuildDownloadTemplatesRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		template string
	)
	{
		p, ok := v.(*product.DownloadTemplatesReq)
		if !ok {
			return nil, goahttp.ErrInvalidType("product", "download_templates", "*product.DownloadTemplatesReq", v)
		}
		if p.Template != nil {
			template = *p.Template
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DownloadTemplatesProductPath(template)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "download_templates", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDownloadTemplatesRequest returns an encoder for requests sent to the
// product download_templates server.
func EncodeDownloadTemplatesRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.DownloadTemplatesReq)
		if !ok {
			return goahttp.ErrInvalidType("product", "download_templates", "*product.DownloadTemplatesReq", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeDownloadTemplatesResponse returns a decoder for responses returned by
// the product download_templates endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDownloadTemplatesResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "internal_error" (type *goa.ServiceError): http.StatusInternalServerError
//	- error: internal error
func DecodeDownloadTemplatesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				length int64
				err    error
			)
			{
				lengthRaw := resp.Header.Get("Content-Length")
				if lengthRaw == "" {
					return nil, goahttp.ErrValidationError("product", "download_templates", goa.MissingFieldError("Content-Length", "header"))
				}
				v, err2 := strconv.ParseInt(lengthRaw, 10, 64)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("length", lengthRaw, "integer"))
				}
				length = v
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "download_templates", err)
			}
			res := NewDownloadTemplatesExportProductResultOK(length)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body DownloadTemplatesUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "download_templates", err)
			}
			err = ValidateDownloadTemplatesUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "download_templates", err)
			}
			return nil, NewDownloadTemplatesUnauthorized(&body)
		case http.StatusInternalServerError:
			var (
				body DownloadTemplatesInternalErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "download_templates", err)
			}
			err = ValidateDownloadTemplatesInternalErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "download_templates", err)
			}
			return nil, NewDownloadTemplatesInternalError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "download_templates", resp.StatusCode, string(body))
		}
	}
}

// BuildUploadProductRequest instantiates a HTTP request object with method and
// path set to call the "product" service "upload_product" endpoint
func (c *Client) BuildUploadProductRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UploadProductProductPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "upload_product", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUploadProductRequest returns an encoder for requests sent to the
// product upload_product server.
func EncodeUploadProductRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.UploadProductPayload)
		if !ok {
			return goahttp.ErrInvalidType("product", "upload_product", "*product.UploadProductPayload", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if err := encoder(req).Encode(p); err != nil {
			return goahttp.ErrEncodingError("product", "upload_product", err)
		}
		return nil
	}
}

// NewProductUploadProductEncoder returns an encoder to encode the multipart
// request for the "product" service "upload_product" endpoint.
func NewProductUploadProductEncoder(encoderFn ProductUploadProductEncoderFunc) func(r *http.Request) goahttp.Encoder {
	return func(r *http.Request) goahttp.Encoder {
		body := &bytes.Buffer{}
		mw := multipart.NewWriter(body)
		return goahttp.EncodingFunc(func(v interface{}) error {
			p := v.(*product.UploadProductPayload)
			if err := encoderFn(mw, p); err != nil {
				return err
			}
			r.Body = ioutil.NopCloser(body)
			r.Header.Set("Content-Type", mw.FormDataContentType())
			return mw.Close()
		})
	}
}

// DecodeUploadProductResponse returns a decoder for responses returned by the
// product upload_product endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeUploadProductResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- error: internal error
func DecodeUploadProductResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UploadProductResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "upload_product", err)
			}
			err = ValidateUploadProductResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "upload_product", err)
			}
			res := NewUploadProductResponseOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body UploadProductUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "upload_product", err)
			}
			err = ValidateUploadProductUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "upload_product", err)
			}
			return nil, NewUploadProductUnauthorized(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "upload_product", resp.StatusCode, string(body))
		}
	}
}

// BuildUploadProductUpdateRequest instantiates a HTTP request object with
// method and path set to call the "product" service "upload_product_update"
// endpoint
func (c *Client) BuildUploadProductUpdateRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UploadProductUpdateProductPath()}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "upload_product_update", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUploadProductUpdateRequest returns an encoder for requests sent to the
// product upload_product_update server.
func EncodeUploadProductUpdateRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.UploadProductPayload)
		if !ok {
			return goahttp.ErrInvalidType("product", "upload_product_update", "*product.UploadProductPayload", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if err := encoder(req).Encode(p); err != nil {
			return goahttp.ErrEncodingError("product", "upload_product_update", err)
		}
		return nil
	}
}

// NewProductUploadProductUpdateEncoder returns an encoder to encode the
// multipart request for the "product" service "upload_product_update" endpoint.
func NewProductUploadProductUpdateEncoder(encoderFn ProductUploadProductUpdateEncoderFunc) func(r *http.Request) goahttp.Encoder {
	return func(r *http.Request) goahttp.Encoder {
		body := &bytes.Buffer{}
		mw := multipart.NewWriter(body)
		return goahttp.EncodingFunc(func(v interface{}) error {
			p := v.(*product.UploadProductPayload)
			if err := encoderFn(mw, p); err != nil {
				return err
			}
			r.Body = ioutil.NopCloser(body)
			r.Header.Set("Content-Type", mw.FormDataContentType())
			return mw.Close()
		})
	}
}

// DecodeUploadProductUpdateResponse returns a decoder for responses returned
// by the product upload_product_update endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeUploadProductUpdateResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- error: internal error
func DecodeUploadProductUpdateResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UploadProductUpdateResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "upload_product_update", err)
			}
			err = ValidateUploadProductUpdateResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "upload_product_update", err)
			}
			res := NewUploadProductUpdateUploadProductResponseOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body UploadProductUpdateUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "upload_product_update", err)
			}
			err = ValidateUploadProductUpdateUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "upload_product_update", err)
			}
			return nil, NewUploadProductUpdateUnauthorized(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "upload_product_update", resp.StatusCode, string(body))
		}
	}
}

// BuildGenerateBarcodeRequest instantiates a HTTP request object with method
// and path set to call the "product" service "generate_barcode" endpoint
func (c *Client) BuildGenerateBarcodeRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GenerateBarcodeProductPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "generate_barcode", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGenerateBarcodeRequest returns an encoder for requests sent to the
// product generate_barcode server.
func EncodeGenerateBarcodeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.AuthToken)
		if !ok {
			return goahttp.ErrInvalidType("product", "generate_barcode", "*product.AuthToken", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeGenerateBarcodeResponse returns a decoder for responses returned by
// the product generate_barcode endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGenerateBarcodeResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- error: internal error
func DecodeGenerateBarcodeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GenerateBarcodeResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "generate_barcode", err)
			}
			err = ValidateGenerateBarcodeResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "generate_barcode", err)
			}
			res := NewGenerateBarcodeBarCodeRspOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body GenerateBarcodeUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "generate_barcode", err)
			}
			err = ValidateGenerateBarcodeUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "generate_barcode", err)
			}
			return nil, NewGenerateBarcodeUnauthorized(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "generate_barcode", resp.StatusCode, string(body))
		}
	}
}

// BuildProductsQueryRequest instantiates a HTTP request object with method and
// path set to call the "product" service "products_query" endpoint
func (c *Client) BuildProductsQueryRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ProductsQueryProductPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "products_query", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeProductsQueryRequest returns an encoder for requests sent to the
// product products_query server.
func EncodeProductsQueryRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.ProductsQueryReq)
		if !ok {
			return goahttp.ErrInvalidType("product", "products_query", "*product.ProductsQueryReq", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Name != nil {
			values.Add("name", *p.Name)
		}
		if p.Sku != nil {
			values.Add("sku", *p.Sku)
		}
		if p.Barcode != nil {
			values.Add("barcode", *p.Barcode)
		}
		if p.Status != nil {
			values.Add("status", fmt.Sprintf("%v", *p.Status))
		}
		for _, value := range p.Attributes {
			values.Add("attributes", value)
		}
		if p.Inventory != nil {
			values.Add("inventory", fmt.Sprintf("%v", *p.Inventory))
		}
		if p.Current != nil {
			values.Add("current", fmt.Sprintf("%v", *p.Current))
		}
		if p.PageSize != nil {
			values.Add("page_size", fmt.Sprintf("%v", *p.PageSize))
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeProductsQueryResponse returns a decoder for responses returned by the
// product products_query endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeProductsQueryResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- error: internal error
func DecodeProductsQueryResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ProductsQueryResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "products_query", err)
			}
			err = ValidateProductsQueryResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "products_query", err)
			}
			res := NewProductsQueryRspOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body ProductsQueryUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "products_query", err)
			}
			err = ValidateProductsQueryUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "products_query", err)
			}
			return nil, NewProductsQueryUnauthorized(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "products_query", resp.StatusCode, string(body))
		}
	}
}

// BuildProductDetailRequest instantiates a HTTP request object with method and
// path set to call the "product" service "product_detail" endpoint
func (c *Client) BuildProductDetailRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int32
	)
	{
		p, ok := v.(*product.ProductDetailReq)
		if !ok {
			return nil, goahttp.ErrInvalidType("product", "product_detail", "*product.ProductDetailReq", v)
		}
		if p.ID != nil {
			id = *p.ID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ProductDetailProductPath(id)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("product", "product_detail", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeProductDetailRequest returns an encoder for requests sent to the
// product product_detail server.
func EncodeProductDetailRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*product.ProductDetailReq)
		if !ok {
			return goahttp.ErrInvalidType("product", "product_detail", "*product.ProductDetailReq", v)
		}
		if p.Authorization != nil {
			head := *p.Authorization
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.Token != nil {
			head := *p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeProductDetailResponse returns a decoder for responses returned by the
// product product_detail endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeProductDetailResponse may return the following errors:
//	- "Unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- error: internal error
func DecodeProductDetailResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ProductDetailResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "product_detail", err)
			}
			err = ValidateProductDetailResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "product_detail", err)
			}
			res := NewProductDetailRspOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body ProductDetailUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("product", "product_detail", err)
			}
			err = ValidateProductDetailUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("product", "product_detail", err)
			}
			return nil, NewProductDetailUnauthorized(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("product", "product_detail", resp.StatusCode, string(body))
		}
	}
}

// marshalProductProductToProductRequestBody builds a value of type
// *ProductRequestBody from a value of type *product.Product.
func marshalProductProductToProductRequestBody(v *product.Product) *ProductRequestBody {
	res := &ProductRequestBody{
		Sku:                v.Sku,
		Name:               v.Name,
		DeclaredEnName:     v.DeclaredEnName,
		DeclaredCnName:     v.DeclaredCnName,
		DeclaredValueInUsd: v.DeclaredValueInUsd,
		Weight:             v.Weight,
		Length:             v.Length,
		Width:              v.Width,
		Height:             v.Height,
		HsCode:             v.HsCode,
		Barcode:            v.Barcode,
		Qty:                v.Qty,
		EnabledNssBarcode:  v.EnabledNssBarcode,
		DeclaredValueInEur: v.DeclaredValueInEur,
		CustomerCode:       v.CustomerCode,
		ID:                 v.ID,
		BarcodeService:     v.BarcodeService,
		ErrorMessage:       v.ErrorMessage,
		Material:           v.Material,
		Purpose:            v.Purpose,
		Authorization:      v.Authorization,
		Token:              v.Token,
	}
	if v.Images != nil {
		res.Images = make([]string, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = val
		}
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	{
		var zero string
		if res.Material == zero {
			res.Material = ""
		}
	}
	{
		var zero string
		if res.Purpose == zero {
			res.Purpose = ""
		}
	}

	return res
}

// marshalProductRequestBodyToProductProduct builds a value of type
// *product.Product from a value of type *ProductRequestBody.
func marshalProductRequestBodyToProductProduct(v *ProductRequestBody) *product.Product {
	res := &product.Product{
		Sku:                v.Sku,
		Name:               v.Name,
		DeclaredEnName:     v.DeclaredEnName,
		DeclaredCnName:     v.DeclaredCnName,
		DeclaredValueInUsd: v.DeclaredValueInUsd,
		Weight:             v.Weight,
		Length:             v.Length,
		Width:              v.Width,
		Height:             v.Height,
		HsCode:             v.HsCode,
		Barcode:            v.Barcode,
		Qty:                v.Qty,
		EnabledNssBarcode:  v.EnabledNssBarcode,
		DeclaredValueInEur: v.DeclaredValueInEur,
		CustomerCode:       v.CustomerCode,
		ID:                 v.ID,
		BarcodeService:     v.BarcodeService,
		ErrorMessage:       v.ErrorMessage,
		Material:           v.Material,
		Purpose:            v.Purpose,
		Authorization:      v.Authorization,
		Token:              v.Token,
	}
	if v.Images != nil {
		res.Images = make([]string, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = val
		}
	}
	if v.Attributes != nil {
		res.Attributes = make([]string, len(v.Attributes))
		for i, val := range v.Attributes {
			res.Attributes[i] = val
		}
	}
	{
		var zero string
		if res.Material == zero {
			res.Material = ""
		}
	}
	{
		var zero string
		if res.Purpose == zero {
			res.Purpose = ""
		}
	}

	return res
}

// unmarshalMultiProductInfoResponseBodyToProductMultiProductInfo builds a
// value of type *product.MultiProductInfo from a value of type
// *MultiProductInfoResponseBody.
func unmarshalMultiProductInfoResponseBodyToProductMultiProductInfo(v *MultiProductInfoResponseBody) *product.MultiProductInfo {
	if v == nil {
		return nil
	}
	res := &product.MultiProductInfo{}
	res.Products = make([]*product.MultiProductData, len(v.Products))
	for i, val := range v.Products {
		res.Products[i] = unmarshalMultiProductDataResponseBodyToProductMultiProductData(val)
	}

	return res
}

// unmarshalMultiProductDataResponseBodyToProductMultiProductData builds a
// value of type *product.MultiProductData from a value of type
// *MultiProductDataResponseBody.
func unmarshalMultiProductDataResponseBodyToProductMultiProductData(v *MultiProductDataResponseBody) *product.MultiProductData {
	res := &product.MultiProductData{
		ProductID:   *v.ProductID,
		Status:      *v.Status,
		ErrorMsg:    *v.ErrorMsg,
		Barcode:     *v.Barcode,
		Sku:         *v.Sku,
		ProductName: *v.ProductName,
	}

	return res
}

// unmarshalUpdateResponseDataResponseBodyToProductUpdateResponseData builds a
// value of type *product.UpdateResponseData from a value of type
// *UpdateResponseDataResponseBody.
func unmarshalUpdateResponseDataResponseBodyToProductUpdateResponseData(v *UpdateResponseDataResponseBody) *product.UpdateResponseData {
	if v == nil {
		return nil
	}
	res := &product.UpdateResponseData{
		Status: *v.Status,
	}

	return res
}

// unmarshalUploadProductResponseDataResponseBodyToProductUploadProductResponseData
// builds a value of type *product.UploadProductResponseData from a value of
// type *UploadProductResponseDataResponseBody.
func unmarshalUploadProductResponseDataResponseBodyToProductUploadProductResponseData(v *UploadProductResponseDataResponseBody) *product.UploadProductResponseData {
	if v == nil {
		return nil
	}
	res := &product.UploadProductResponseData{
		TotalCount:   v.TotalCount,
		SuccessCount: v.SuccessCount,
		FailCount:    v.FailCount,
		ResultFile:   *v.ResultFile,
	}

	return res
}

// unmarshalBarCodeDataResponseBodyToProductBarCodeData builds a value of type
// *product.BarCodeData from a value of type *BarCodeDataResponseBody.
func unmarshalBarCodeDataResponseBodyToProductBarCodeData(v *BarCodeDataResponseBody) *product.BarCodeData {
	if v == nil {
		return nil
	}
	res := &product.BarCodeData{
		Barcode: *v.Barcode,
	}

	return res
}

// unmarshalProductsQueryDataResponseBodyToProductProductsQueryData builds a
// value of type *product.ProductsQueryData from a value of type
// *ProductsQueryDataResponseBody.
func unmarshalProductsQueryDataResponseBodyToProductProductsQueryData(v *ProductsQueryDataResponseBody) *product.ProductsQueryData {
	if v == nil {
		return nil
	}
	res := &product.ProductsQueryData{}
	res.List = make([]*product.ProductItem, len(v.List))
	for i, val := range v.List {
		res.List[i] = unmarshalProductItemResponseBodyToProductProductItem(val)
	}
	if v.Meta != nil {
		res.Meta = unmarshalMetaDataResponseBodyToProductMetaData(v.Meta)
	}

	return res
}

// unmarshalProductItemResponseBodyToProductProductItem builds a value of type
// *product.ProductItem from a value of type *ProductItemResponseBody.
func unmarshalProductItemResponseBodyToProductProductItem(v *ProductItemResponseBody) *product.ProductItem {
	res := &product.ProductItem{
		ID:            *v.ID,
		Status:        *v.Status,
		Barcode:       *v.Barcode,
		Sku:           *v.Sku,
		Name:          *v.Name,
		Inventory:     *v.Inventory,
		Weight:        *v.Weight,
		InboundWeight: *v.InboundWeight,
		Length:        *v.Length,
		Width:         *v.Width,
		Height:        *v.Height,
	}
	res.Attributes = make([]string, len(v.Attributes))
	for i, val := range v.Attributes {
		res.Attributes[i] = val
	}
	res.Images = make([]string, len(v.Images))
	for i, val := range v.Images {
		res.Images[i] = val
	}

	return res
}

// unmarshalMetaDataResponseBodyToProductMetaData builds a value of type
// *product.MetaData from a value of type *MetaDataResponseBody.
func unmarshalMetaDataResponseBodyToProductMetaData(v *MetaDataResponseBody) *product.MetaData {
	if v == nil {
		return nil
	}
	res := &product.MetaData{
		Current:  *v.Current,
		PageSize: *v.PageSize,
		Total:    *v.Total,
	}

	return res
}

// unmarshalProductDetailDataResponseBodyToProductProductDetailData builds a
// value of type *product.ProductDetailData from a value of type
// *ProductDetailDataResponseBody.
func unmarshalProductDetailDataResponseBodyToProductProductDetailData(v *ProductDetailDataResponseBody) *product.ProductDetailData {
	if v == nil {
		return nil
	}
	res := &product.ProductDetailData{
		ID:                 *v.ID,
		Status:             *v.Status,
		Barcode:            *v.Barcode,
		Sku:                *v.Sku,
		Name:               *v.Name,
		Weight:             *v.Weight,
		HsCode:             *v.HsCode,
		DeclaredCnName:     *v.DeclaredCnName,
		DeclaredEnName:     *v.DeclaredEnName,
		DeclaredValueInUsd: *v.DeclaredValueInUsd,
		DeclaredValueInEur: *v.DeclaredValueInEur,
		BarcodeService:     *v.BarcodeService,
	}
	res.Attributes = make([]string, len(v.Attributes))
	for i, val := range v.Attributes {
		res.Attributes[i] = val
	}
	res.Images = make([]string, len(v.Images))
	for i, val := range v.Images {
		res.Images[i] = val
	}

	return res
}
