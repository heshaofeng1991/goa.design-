// Code generated by goa v3.6.2, DO NOT EDIT.
//
// order HTTP server encoders and decoders
//
// Command:
// $ goa gen goa/design -o ./

package server

import (
	"context"
	"errors"
	order "goa/gen/order"
	"io"
	"net/http"
	"strconv"
	"strings"
	"unicode/utf8"

	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeCreateInboundOrderResponse returns an encoder for responses returned
// by the order create_inbound_order endpoint.
func EncodeCreateInboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.InboundOrderRsp)
		enc := encoder(ctx, w)
		body := NewCreateInboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateInboundOrderRequest returns a decoder for requests sent to the
// order create_inbound_order endpoint.
func DecodeCreateInboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreateInboundOrderRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateInboundOrderRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			authorization *string
			token         *string
		)
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewCreateInboundOrderInboundOrder(&body, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateInboundOrderError returns an encoder for errors returned by the
// create_inbound_order order endpoint.
func EncodeCreateInboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateInboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateInboundOrderResponse returns an encoder for responses returned
// by the order update_inbound_order endpoint.
func EncodeUpdateInboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.UpdateResponse)
		enc := encoder(ctx, w)
		body := NewUpdateInboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateInboundOrderRequest returns a decoder for requests sent to the
// order update_inbound_order endpoint.
func DecodeUpdateInboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body UpdateInboundOrderRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateInboundOrderRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			authorization *string
			token         *string
		)
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewUpdateInboundOrderInboundOrder(&body, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateInboundOrderError returns an encoder for errors returned by the
// update_inbound_order order endpoint.
func EncodeUpdateInboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateInboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreatePickupOrderResponse returns an encoder for responses returned by
// the order create_pickup_order endpoint.
func EncodeCreatePickupOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.PickupOrderRsp)
		enc := encoder(ctx, w)
		body := NewCreatePickupOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreatePickupOrderRequest returns a decoder for requests sent to the
// order create_pickup_order endpoint.
func DecodeCreatePickupOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreatePickupOrderRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreatePickupOrderRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			authorization *string
			token         *string
		)
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewCreatePickupOrderPickupOrder(&body, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreatePickupOrderError returns an encoder for errors returned by the
// create_pickup_order order endpoint.
func EncodeCreatePickupOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreatePickupOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeBatchQueryInboundOrderResponse returns an encoder for responses
// returned by the order batch_query_inbound_order endpoint.
func EncodeBatchQueryInboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.InboundOrderResponse)
		enc := encoder(ctx, w)
		body := NewBatchQueryInboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeBatchQueryInboundOrderRequest returns a decoder for requests sent to
// the order batch_query_inbound_order endpoint.
func DecodeBatchQueryInboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			orderNumbers  []string
			status        *int
			current       *int
			pageSize      *int
			authorization *string
			token         *string
			err           error
		)
		orderNumbers = r.URL.Query()["order_numbers"]
		if len(orderNumbers) > 50 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("orderNumbers", orderNumbers, len(orderNumbers), 50, false))
		}
		{
			statusRaw := r.URL.Query().Get("status")
			if statusRaw != "" {
				v, err2 := strconv.ParseInt(statusRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("status", statusRaw, "integer"))
				}
				pv := int(v)
				status = &pv
			}
		}
		if status != nil {
			if *status < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("status", *status, 0, true))
			}
		}
		if status != nil {
			if *status > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("status", *status, 100, false))
			}
		}
		{
			currentRaw := r.URL.Query().Get("current")
			if currentRaw != "" {
				v, err2 := strconv.ParseInt(currentRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("current", currentRaw, "integer"))
				}
				pv := int(v)
				current = &pv
			}
		}
		if current != nil {
			if *current < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("current", *current, 1, true))
			}
		}
		{
			pageSizeRaw := r.URL.Query().Get("page_size")
			if pageSizeRaw != "" {
				v, err2 := strconv.ParseInt(pageSizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("pageSize", pageSizeRaw, "integer"))
				}
				pv := int(v)
				pageSize = &pv
			}
		}
		if pageSize != nil {
			if *pageSize < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("pageSize", *pageSize, 1, true))
			}
		}
		if pageSize != nil {
			if *pageSize > 50 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("pageSize", *pageSize, 50, false))
			}
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewBatchQueryInboundOrderGetOrder(orderNumbers, status, current, pageSize, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeBatchQueryInboundOrderError returns an encoder for errors returned by
// the batch_query_inbound_order order endpoint.
func EncodeBatchQueryInboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchQueryInboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetInboundOrderResponse returns an encoder for responses returned by
// the order get_inbound_order endpoint.
func EncodeGetInboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.QueryInboundOrderRsp)
		enc := encoder(ctx, w)
		body := NewGetInboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetInboundOrderRequest returns a decoder for requests sent to the
// order get_inbound_order endpoint.
func DecodeGetInboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			orderNumber   string
			authorization *string
			token         *string
			err           error

			params = mux.Vars(r)
		)
		orderNumber = params["order_number"]
		if utf8.RuneCountInString(orderNumber) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("orderNumber", orderNumber, utf8.RuneCountInString(orderNumber), 1, true))
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetInboundOrderQueryOrder(orderNumber, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetInboundOrderError returns an encoder for errors returned by the
// get_inbound_order order endpoint.
func EncodeGetInboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetInboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateOutboundOrderResponse returns an encoder for responses returned
// by the order create_outbound_order endpoint.
func EncodeCreateOutboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.OutboundOrderRsp)
		enc := encoder(ctx, w)
		body := NewCreateOutboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateOutboundOrderRequest returns a decoder for requests sent to the
// order create_outbound_order endpoint.
func DecodeCreateOutboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreateOutboundOrderRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateOutboundOrderRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			authorization *string
			token         *string
		)
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewCreateOutboundOrderOutboundOrder(&body, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateOutboundOrderError returns an encoder for errors returned by the
// create_outbound_order order endpoint.
func EncodeCreateOutboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateOutboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateOutboundOrderResponse returns an encoder for responses returned
// by the order update_outbound_order endpoint.
func EncodeUpdateOutboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.UpdateResponse)
		enc := encoder(ctx, w)
		body := NewUpdateOutboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateOutboundOrderRequest returns a decoder for requests sent to the
// order update_outbound_order endpoint.
func DecodeUpdateOutboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body UpdateOutboundOrderRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateOutboundOrderRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			id            int32
			authorization *string
			token         *string

			params = mux.Vars(r)
		)
		{
			idRaw := params["id"]
			v, err2 := strconv.ParseInt(idRaw, 10, 32)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("id", idRaw, "integer"))
			}
			id = int32(v)
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateOutboundOrderOutboundOrderUpdateRequest(&body, id, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateOutboundOrderError returns an encoder for errors returned by the
// update_outbound_order order endpoint.
func EncodeUpdateOutboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateOutboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeBatchUpdateOutboundOrderResponse returns an encoder for responses
// returned by the order batch_update_outbound_order endpoint.
func EncodeBatchUpdateOutboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.BatchUpdateOrderResponse)
		enc := encoder(ctx, w)
		body := NewBatchUpdateOutboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeBatchUpdateOutboundOrderRequest returns a decoder for requests sent to
// the order batch_update_outbound_order endpoint.
func DecodeBatchUpdateOutboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body BatchUpdateOutboundOrderRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateBatchUpdateOutboundOrderRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			authorization *string
			token         *string
		)
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewBatchUpdateOutboundOrderBatchUpdateOrderRequest(&body, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeBatchUpdateOutboundOrderError returns an encoder for errors returned
// by the batch_update_outbound_order order endpoint.
func EncodeBatchUpdateOutboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchUpdateOutboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateOutboundOrderItemResponse returns an encoder for responses
// returned by the order create_outbound_order_item endpoint.
func EncodeCreateOutboundOrderItemResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.BaseResponse)
		enc := encoder(ctx, w)
		body := NewCreateOutboundOrderItemResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateOutboundOrderItemRequest returns a decoder for requests sent to
// the order create_outbound_order_item endpoint.
func DecodeCreateOutboundOrderItemRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreateOutboundOrderItemRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateOutboundOrderItemRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			authorization *string
			token         *string
		)
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewCreateOutboundOrderItemOutboundOrderItemCreateRequest(&body, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateOutboundOrderItemError returns an encoder for errors returned by
// the create_outbound_order_item order endpoint.
func EncodeCreateOutboundOrderItemError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateOutboundOrderItemUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateOutboundOrderItemResponse returns an encoder for responses
// returned by the order update_outbound_order_item endpoint.
func EncodeUpdateOutboundOrderItemResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.BaseResponse)
		enc := encoder(ctx, w)
		body := NewUpdateOutboundOrderItemResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateOutboundOrderItemRequest returns a decoder for requests sent to
// the order update_outbound_order_item endpoint.
func DecodeUpdateOutboundOrderItemRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body UpdateOutboundOrderItemRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateOutboundOrderItemRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			id            int64
			authorization *string
			token         *string

			params = mux.Vars(r)
		)
		{
			idRaw := params["id"]
			v, err2 := strconv.ParseInt(idRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("id", idRaw, "integer"))
			}
			id = v
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateOutboundOrderItemOutboundOrderItemUpdateRequest(&body, id, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateOutboundOrderItemError returns an encoder for errors returned by
// the update_outbound_order_item order endpoint.
func EncodeUpdateOutboundOrderItemError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateOutboundOrderItemUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteOutboundOrderItemResponse returns an encoder for responses
// returned by the order delete_outbound_order_item endpoint.
func EncodeDeleteOutboundOrderItemResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.BaseResponse)
		enc := encoder(ctx, w)
		body := NewDeleteOutboundOrderItemResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDeleteOutboundOrderItemRequest returns a decoder for requests sent to
// the order delete_outbound_order_item endpoint.
func DecodeDeleteOutboundOrderItemRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id            int64
			authorization *string
			token         *string
			err           error

			params = mux.Vars(r)
		)
		{
			idRaw := params["id"]
			v, err2 := strconv.ParseInt(idRaw, 10, 64)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("id", idRaw, "integer"))
			}
			id = v
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteOutboundOrderItemDeleteOutboundItemRequest(id, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteOutboundOrderItemError returns an encoder for errors returned by
// the delete_outbound_order_item order endpoint.
func EncodeDeleteOutboundOrderItemError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteOutboundOrderItemUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeBatchQueryOutboundOrderResponse returns an encoder for responses
// returned by the order batch_query_outbound_order endpoint.
func EncodeBatchQueryOutboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.OrderRsp)
		enc := encoder(ctx, w)
		body := NewBatchQueryOutboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeBatchQueryOutboundOrderRequest returns a decoder for requests sent to
// the order batch_query_outbound_order endpoint.
func DecodeBatchQueryOutboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			orderNumbers  []string
			status        *int
			current       *int
			pageSize      *int
			authorization *string
			token         *string
			err           error
		)
		orderNumbers = r.URL.Query()["order_numbers"]
		if len(orderNumbers) > 50 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("orderNumbers", orderNumbers, len(orderNumbers), 50, false))
		}
		{
			statusRaw := r.URL.Query().Get("status")
			if statusRaw != "" {
				v, err2 := strconv.ParseInt(statusRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("status", statusRaw, "integer"))
				}
				pv := int(v)
				status = &pv
			}
		}
		if status != nil {
			if *status < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("status", *status, 0, true))
			}
		}
		if status != nil {
			if *status > 100 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("status", *status, 100, false))
			}
		}
		{
			currentRaw := r.URL.Query().Get("current")
			if currentRaw != "" {
				v, err2 := strconv.ParseInt(currentRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("current", currentRaw, "integer"))
				}
				pv := int(v)
				current = &pv
			}
		}
		if current != nil {
			if *current < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("current", *current, 1, true))
			}
		}
		{
			pageSizeRaw := r.URL.Query().Get("page_size")
			if pageSizeRaw != "" {
				v, err2 := strconv.ParseInt(pageSizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("pageSize", pageSizeRaw, "integer"))
				}
				pv := int(v)
				pageSize = &pv
			}
		}
		if pageSize != nil {
			if *pageSize < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("pageSize", *pageSize, 1, true))
			}
		}
		if pageSize != nil {
			if *pageSize > 50 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("pageSize", *pageSize, 50, false))
			}
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewBatchQueryOutboundOrderGetOrder(orderNumbers, status, current, pageSize, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeBatchQueryOutboundOrderError returns an encoder for errors returned by
// the batch_query_outbound_order order endpoint.
func EncodeBatchQueryOutboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchQueryOutboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetOutboundOrderResponse returns an encoder for responses returned by
// the order get_outbound_order endpoint.
func EncodeGetOutboundOrderResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.QueryOrderRsp)
		enc := encoder(ctx, w)
		body := NewGetOutboundOrderResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetOutboundOrderRequest returns a decoder for requests sent to the
// order get_outbound_order endpoint.
func DecodeGetOutboundOrderRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id            string
			authorization *string
			token         *string
			err           error

			params = mux.Vars(r)
		)
		id = params["id"]
		if utf8.RuneCountInString(id) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("id", id, utf8.RuneCountInString(id), 1, true))
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetOutboundOrderQueryOutOrder(id, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetOutboundOrderError returns an encoder for errors returned by the
// get_outbound_order order endpoint.
func EncodeGetOutboundOrderError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetOutboundOrderUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetOutboundOrderListFiltersResponse returns an encoder for responses
// returned by the order get_outbound_order_list_filters endpoint.
func EncodeGetOutboundOrderListFiltersResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.OrderListFilters)
		enc := encoder(ctx, w)
		body := NewGetOutboundOrderListFiltersResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetOutboundOrderListFiltersRequest returns a decoder for requests sent
// to the order get_outbound_order_list_filters endpoint.
func DecodeGetOutboundOrderListFiltersRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			authorization *string
			token         *string
		)
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewGetOutboundOrderListFiltersAuthToken(authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetOutboundOrderListFiltersError returns an encoder for errors
// returned by the get_outbound_order_list_filters order endpoint.
func EncodeGetOutboundOrderListFiltersError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetOutboundOrderListFiltersUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetOutboundOrderCountResponse returns an encoder for responses
// returned by the order get_outbound_order_count endpoint.
func EncodeGetOutboundOrderCountResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.OrderCountResult)
		enc := encoder(ctx, w)
		body := NewGetOutboundOrderCountResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetOutboundOrderCountRequest returns a decoder for requests sent to
// the order get_outbound_order_count endpoint.
func DecodeGetOutboundOrderCountRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id                []string
			platformOrderNo   *string
			listingSku        *string
			sku               *string
			nssTrackingNumber *string
			shippingName      *string
			platform          *string
			status            []string
			storeID           *string
			warehouseID       *string
			countryCode       *string
			createdAtStart    *string
			createdAtEnd      *string
			shipDateStart     *string
			shipDateEnd       *string
			offlineOrder      *string
			page              *string
			pageSize          *string
			authorization     *string
			token             *string
		)
		id = r.URL.Query()["id"]
		platformOrderNoRaw := r.URL.Query().Get("platform_order_no")
		if platformOrderNoRaw != "" {
			platformOrderNo = &platformOrderNoRaw
		}
		listingSkuRaw := r.URL.Query().Get("listing_sku")
		if listingSkuRaw != "" {
			listingSku = &listingSkuRaw
		}
		skuRaw := r.URL.Query().Get("sku")
		if skuRaw != "" {
			sku = &skuRaw
		}
		nssTrackingNumberRaw := r.URL.Query().Get("nss_tracking_number")
		if nssTrackingNumberRaw != "" {
			nssTrackingNumber = &nssTrackingNumberRaw
		}
		shippingNameRaw := r.URL.Query().Get("shipping_name")
		if shippingNameRaw != "" {
			shippingName = &shippingNameRaw
		}
		platformRaw := r.URL.Query().Get("platform")
		if platformRaw != "" {
			platform = &platformRaw
		}
		status = r.URL.Query()["status"]
		storeIDRaw := r.URL.Query().Get("store_id")
		if storeIDRaw != "" {
			storeID = &storeIDRaw
		}
		warehouseIDRaw := r.URL.Query().Get("warehouse_id")
		if warehouseIDRaw != "" {
			warehouseID = &warehouseIDRaw
		}
		countryCodeRaw := r.URL.Query().Get("country_code")
		if countryCodeRaw != "" {
			countryCode = &countryCodeRaw
		}
		createdAtStartRaw := r.URL.Query().Get("created_at_start")
		if createdAtStartRaw != "" {
			createdAtStart = &createdAtStartRaw
		}
		createdAtEndRaw := r.URL.Query().Get("created_at_end")
		if createdAtEndRaw != "" {
			createdAtEnd = &createdAtEndRaw
		}
		shipDateStartRaw := r.URL.Query().Get("ship_date_start")
		if shipDateStartRaw != "" {
			shipDateStart = &shipDateStartRaw
		}
		shipDateEndRaw := r.URL.Query().Get("ship_date_end")
		if shipDateEndRaw != "" {
			shipDateEnd = &shipDateEndRaw
		}
		offlineOrderRaw := r.URL.Query().Get("offline_order")
		if offlineOrderRaw != "" {
			offlineOrder = &offlineOrderRaw
		}
		pageRaw := r.URL.Query().Get("page")
		if pageRaw != "" {
			page = &pageRaw
		}
		pageSizeRaw := r.URL.Query().Get("page_size")
		if pageSizeRaw != "" {
			pageSize = &pageSizeRaw
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewGetOutboundOrderCountOrderQueryPayload(id, platformOrderNo, listingSku, sku, nssTrackingNumber, shippingName, platform, status, storeID, warehouseID, countryCode, createdAtStart, createdAtEnd, shipDateStart, shipDateEnd, offlineOrder, page, pageSize, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetOutboundOrderCountError returns an encoder for errors returned by
// the get_outbound_order_count order endpoint.
func EncodeGetOutboundOrderCountError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetOutboundOrderCountUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetOutboundOrderListResponse returns an encoder for responses returned
// by the order get_outbound_order_list endpoint.
func EncodeGetOutboundOrderListResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.GetOrderListResult)
		enc := encoder(ctx, w)
		body := NewGetOutboundOrderListResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetOutboundOrderListRequest returns a decoder for requests sent to the
// order get_outbound_order_list endpoint.
func DecodeGetOutboundOrderListRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id                []string
			platformOrderNo   *string
			listingSku        *string
			sku               *string
			nssTrackingNumber *string
			shippingName      *string
			platform          *string
			status            []string
			storeID           *string
			warehouseID       *string
			countryCode       *string
			createdAtStart    *string
			createdAtEnd      *string
			shipDateStart     *string
			shipDateEnd       *string
			offlineOrder      *string
			page              *string
			pageSize          *string
			authorization     *string
			token             *string
		)
		id = r.URL.Query()["id"]
		platformOrderNoRaw := r.URL.Query().Get("platform_order_no")
		if platformOrderNoRaw != "" {
			platformOrderNo = &platformOrderNoRaw
		}
		listingSkuRaw := r.URL.Query().Get("listing_sku")
		if listingSkuRaw != "" {
			listingSku = &listingSkuRaw
		}
		skuRaw := r.URL.Query().Get("sku")
		if skuRaw != "" {
			sku = &skuRaw
		}
		nssTrackingNumberRaw := r.URL.Query().Get("nss_tracking_number")
		if nssTrackingNumberRaw != "" {
			nssTrackingNumber = &nssTrackingNumberRaw
		}
		shippingNameRaw := r.URL.Query().Get("shipping_name")
		if shippingNameRaw != "" {
			shippingName = &shippingNameRaw
		}
		platformRaw := r.URL.Query().Get("platform")
		if platformRaw != "" {
			platform = &platformRaw
		}
		status = r.URL.Query()["status"]
		storeIDRaw := r.URL.Query().Get("store_id")
		if storeIDRaw != "" {
			storeID = &storeIDRaw
		}
		warehouseIDRaw := r.URL.Query().Get("warehouse_id")
		if warehouseIDRaw != "" {
			warehouseID = &warehouseIDRaw
		}
		countryCodeRaw := r.URL.Query().Get("country_code")
		if countryCodeRaw != "" {
			countryCode = &countryCodeRaw
		}
		createdAtStartRaw := r.URL.Query().Get("created_at_start")
		if createdAtStartRaw != "" {
			createdAtStart = &createdAtStartRaw
		}
		createdAtEndRaw := r.URL.Query().Get("created_at_end")
		if createdAtEndRaw != "" {
			createdAtEnd = &createdAtEndRaw
		}
		shipDateStartRaw := r.URL.Query().Get("ship_date_start")
		if shipDateStartRaw != "" {
			shipDateStart = &shipDateStartRaw
		}
		shipDateEndRaw := r.URL.Query().Get("ship_date_end")
		if shipDateEndRaw != "" {
			shipDateEnd = &shipDateEndRaw
		}
		offlineOrderRaw := r.URL.Query().Get("offline_order")
		if offlineOrderRaw != "" {
			offlineOrder = &offlineOrderRaw
		}
		pageRaw := r.URL.Query().Get("page")
		if pageRaw != "" {
			page = &pageRaw
		}
		pageSizeRaw := r.URL.Query().Get("page_size")
		if pageSizeRaw != "" {
			pageSize = &pageSizeRaw
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewGetOutboundOrderListOrderQueryPayload(id, platformOrderNo, listingSku, sku, nssTrackingNumber, shippingName, platform, status, storeID, warehouseID, countryCode, createdAtStart, createdAtEnd, shipDateStart, shipDateEnd, offlineOrder, page, pageSize, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetOutboundOrderListError returns an encoder for errors returned by
// the get_outbound_order_list order endpoint.
func EncodeGetOutboundOrderListError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetOutboundOrderListUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUploadOutboundOrdersResponse returns an encoder for responses returned
// by the order upload_outbound_orders endpoint.
func EncodeUploadOutboundOrdersResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.UploadOrdersResult)
		enc := encoder(ctx, w)
		body := NewUploadOutboundOrdersResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUploadOutboundOrdersRequest returns a decoder for requests sent to the
// order upload_outbound_orders endpoint.
func DecodeUploadOutboundOrdersRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var payload *order.UploadOrdersPayload
		if err := decoder(r).Decode(&payload); err != nil {
			return nil, goa.DecodePayloadError(err.Error())
		}
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// NewOrderUploadOutboundOrdersDecoder returns a decoder to decode the
// multipart request for the "order" service "upload_outbound_orders" endpoint.
func NewOrderUploadOutboundOrdersDecoder(mux goahttp.Muxer, orderUploadOutboundOrdersDecoderFn OrderUploadOutboundOrdersDecoderFunc) func(r *http.Request) goahttp.Decoder {
	return func(r *http.Request) goahttp.Decoder {
		return goahttp.EncodingFunc(func(v interface{}) error {
			mr, merr := r.MultipartReader()
			if merr != nil {
				return merr
			}
			p := v.(**order.UploadOrdersPayload)
			if err := orderUploadOutboundOrdersDecoderFn(mr, p); err != nil {
				return err
			}

			var (
				authorization *string
				token         *string
			)
			authorizationRaw := r.Header.Get("Authorization")
			if authorizationRaw != "" {
				authorization = &authorizationRaw
			}
			tokenRaw := r.Header.Get("Authorization")
			if tokenRaw != "" {
				token = &tokenRaw
			}
			(*p).Authorization = authorization
			(*p).Token = token
			return nil
		})
	}
}

// EncodeUploadOutboundOrdersError returns an encoder for errors returned by
// the upload_outbound_orders order endpoint.
func EncodeUploadOutboundOrdersError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUploadOutboundOrdersUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeExportOutboundOrdersResponse returns an encoder for responses returned
// by the order export_outbound_orders endpoint.
func EncodeExportOutboundOrdersResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res, _ := v.(*order.ExportOrderResult)
		{
			val := res.Length
			lengths := strconv.FormatInt(val, 10)
			w.Header().Set("Content-Length", lengths)
		}
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeExportOutboundOrdersRequest returns a decoder for requests sent to the
// order export_outbound_orders endpoint.
func DecodeExportOutboundOrdersRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			id                []string
			platformOrderNo   *string
			listingSku        *string
			sku               *string
			nssTrackingNumber *string
			shippingName      *string
			platform          *string
			status            []string
			storeID           *string
			warehouseID       *string
			countryCode       *string
			createdAtStart    *string
			createdAtEnd      *string
			shipDateStart     *string
			shipDateEnd       *string
			offlineOrder      *string
			page              *string
			pageSize          *string
			authorization     *string
			token             *string
		)
		id = r.URL.Query()["id"]
		platformOrderNoRaw := r.URL.Query().Get("platform_order_no")
		if platformOrderNoRaw != "" {
			platformOrderNo = &platformOrderNoRaw
		}
		listingSkuRaw := r.URL.Query().Get("listing_sku")
		if listingSkuRaw != "" {
			listingSku = &listingSkuRaw
		}
		skuRaw := r.URL.Query().Get("sku")
		if skuRaw != "" {
			sku = &skuRaw
		}
		nssTrackingNumberRaw := r.URL.Query().Get("nss_tracking_number")
		if nssTrackingNumberRaw != "" {
			nssTrackingNumber = &nssTrackingNumberRaw
		}
		shippingNameRaw := r.URL.Query().Get("shipping_name")
		if shippingNameRaw != "" {
			shippingName = &shippingNameRaw
		}
		platformRaw := r.URL.Query().Get("platform")
		if platformRaw != "" {
			platform = &platformRaw
		}
		status = r.URL.Query()["status"]
		storeIDRaw := r.URL.Query().Get("store_id")
		if storeIDRaw != "" {
			storeID = &storeIDRaw
		}
		warehouseIDRaw := r.URL.Query().Get("warehouse_id")
		if warehouseIDRaw != "" {
			warehouseID = &warehouseIDRaw
		}
		countryCodeRaw := r.URL.Query().Get("country_code")
		if countryCodeRaw != "" {
			countryCode = &countryCodeRaw
		}
		createdAtStartRaw := r.URL.Query().Get("created_at_start")
		if createdAtStartRaw != "" {
			createdAtStart = &createdAtStartRaw
		}
		createdAtEndRaw := r.URL.Query().Get("created_at_end")
		if createdAtEndRaw != "" {
			createdAtEnd = &createdAtEndRaw
		}
		shipDateStartRaw := r.URL.Query().Get("ship_date_start")
		if shipDateStartRaw != "" {
			shipDateStart = &shipDateStartRaw
		}
		shipDateEndRaw := r.URL.Query().Get("ship_date_end")
		if shipDateEndRaw != "" {
			shipDateEnd = &shipDateEndRaw
		}
		offlineOrderRaw := r.URL.Query().Get("offline_order")
		if offlineOrderRaw != "" {
			offlineOrder = &offlineOrderRaw
		}
		pageRaw := r.URL.Query().Get("page")
		if pageRaw != "" {
			page = &pageRaw
		}
		pageSizeRaw := r.URL.Query().Get("page_size")
		if pageSizeRaw != "" {
			pageSize = &pageSizeRaw
		}
		authorizationRaw := r.Header.Get("Authorization")
		if authorizationRaw != "" {
			authorization = &authorizationRaw
		}
		tokenRaw := r.Header.Get("Authorization")
		if tokenRaw != "" {
			token = &tokenRaw
		}
		payload := NewExportOutboundOrdersOrderQueryPayload(id, platformOrderNo, listingSku, sku, nssTrackingNumber, shippingName, platform, status, storeID, warehouseID, countryCode, createdAtStart, createdAtEnd, shipDateStart, shipDateEnd, offlineOrder, page, pageSize, authorization, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}

		return payload, nil
	}
}

// EncodeExportOutboundOrdersError returns an encoder for errors returned by
// the export_outbound_orders order endpoint.
func EncodeExportOutboundOrdersError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en ErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "Unauthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewExportOutboundOrdersUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "internal_error":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewExportOutboundOrdersInternalErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.ErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// unmarshalItemRequestBodyToOrderItem builds a value of type *order.Item from
// a value of type *ItemRequestBody.
func unmarshalItemRequestBodyToOrderItem(v *ItemRequestBody) *order.Item {
	res := &order.Item{
		ProductName:    *v.ProductName,
		ProductSku:     *v.ProductSku,
		ProductBarcode: *v.ProductBarcode,
		Qty:            *v.Qty,
	}

	return res
}

// unmarshalShippingAddressRequestBodyToOrderShippingAddress builds a value of
// type *order.ShippingAddress from a value of type *ShippingAddressRequestBody.
func unmarshalShippingAddressRequestBodyToOrderShippingAddress(v *ShippingAddressRequestBody) *order.ShippingAddress {
	if v == nil {
		return nil
	}
	res := &order.ShippingAddress{
		FirstName:         *v.FirstName,
		LastName:          *v.LastName,
		PhoneNumber:       *v.PhoneNumber,
		CountryName:       *v.CountryName,
		CountryCode:       *v.CountryCode,
		StateName:         *v.StateName,
		StateCode:         *v.StateCode,
		Address1:          *v.Address1,
		Address2:          *v.Address2,
		CityName:          *v.CityName,
		ZipCode:           *v.ZipCode,
		Name:              v.Name,
		Company:           v.Company,
		Email:             v.Email,
		CertificateType:   v.CertificateType,
		CertificateCode:   v.CertificateCode,
		CertificatePeriod: v.CertificatePeriod,
	}

	return res
}

// marshalOrderInboundOrderDataToInboundOrderDataResponseBody builds a value of
// type *InboundOrderDataResponseBody from a value of type
// *order.InboundOrderData.
func marshalOrderInboundOrderDataToInboundOrderDataResponseBody(v *order.InboundOrderData) *InboundOrderDataResponseBody {
	if v == nil {
		return nil
	}
	res := &InboundOrderDataResponseBody{
		OrderNumber: v.OrderNumber,
		LabelURL:    v.LabelURL,
	}

	return res
}

// marshalOrderUpdateResponseDataToUpdateResponseDataResponseBody builds a
// value of type *UpdateResponseDataResponseBody from a value of type
// *order.UpdateResponseData.
func marshalOrderUpdateResponseDataToUpdateResponseDataResponseBody(v *order.UpdateResponseData) *UpdateResponseDataResponseBody {
	if v == nil {
		return nil
	}
	res := &UpdateResponseDataResponseBody{
		Status: v.Status,
	}

	return res
}

// marshalOrderInboundOrderInfoToInboundOrderInfoResponseBody builds a value of
// type *InboundOrderInfoResponseBody from a value of type
// *order.InboundOrderInfo.
func marshalOrderInboundOrderInfoToInboundOrderInfoResponseBody(v *order.InboundOrderInfo) *InboundOrderInfoResponseBody {
	if v == nil {
		return nil
	}
	res := &InboundOrderInfoResponseBody{}
	if v.List != nil {
		res.List = make([]*InboundOrderResponseDataResponseBody, len(v.List))
		for i, val := range v.List {
			res.List[i] = marshalOrderInboundOrderResponseDataToInboundOrderResponseDataResponseBody(val)
		}
	}
	if v.Meta != nil {
		res.Meta = marshalOrderMetaDataToMetaDataResponseBody(v.Meta)
	}

	return res
}

// marshalOrderInboundOrderResponseDataToInboundOrderResponseDataResponseBody
// builds a value of type *InboundOrderResponseDataResponseBody from a value of
// type *order.InboundOrderResponseData.
func marshalOrderInboundOrderResponseDataToInboundOrderResponseDataResponseBody(v *order.InboundOrderResponseData) *InboundOrderResponseDataResponseBody {
	res := &InboundOrderResponseDataResponseBody{
		CustomerOrderID: v.CustomerOrderID,
		Status:          v.Status,
		OrderNumber:     v.OrderNumber,
		TrackingNumber:  v.TrackingNumber,
		TrackingURL:     v.TrackingURL,
		Timestamp:       v.Timestamp,
		CarrierName:     v.CarrierName,
	}
	if v.Items != nil {
		res.Items = make([]*ItemResponseBody, len(v.Items))
		for i, val := range v.Items {
			res.Items[i] = marshalOrderItemToItemResponseBody(val)
		}
	}

	return res
}

// marshalOrderItemToItemResponseBody builds a value of type *ItemResponseBody
// from a value of type *order.Item.
func marshalOrderItemToItemResponseBody(v *order.Item) *ItemResponseBody {
	res := &ItemResponseBody{
		ProductName:    v.ProductName,
		ProductSku:     v.ProductSku,
		ProductBarcode: v.ProductBarcode,
		Qty:            v.Qty,
	}

	return res
}

// marshalOrderMetaDataToMetaDataResponseBody builds a value of type
// *MetaDataResponseBody from a value of type *order.MetaData.
func marshalOrderMetaDataToMetaDataResponseBody(v *order.MetaData) *MetaDataResponseBody {
	res := &MetaDataResponseBody{
		Current:  v.Current,
		PageSize: v.PageSize,
		Total:    v.Total,
	}

	return res
}

// unmarshalOutboundOrderItemRequestBodyToOrderOutboundOrderItem builds a value
// of type *order.OutboundOrderItem from a value of type
// *OutboundOrderItemRequestBody.
func unmarshalOutboundOrderItemRequestBodyToOrderOutboundOrderItem(v *OutboundOrderItemRequestBody) *order.OutboundOrderItem {
	res := &order.OutboundOrderItem{
		ProductName:        *v.ProductName,
		ProductSku:         *v.ProductSku,
		ProductPrice:       *v.ProductPrice,
		Qty:                *v.Qty,
		HsCode:             *v.HsCode,
		DeclaredCnName:     *v.DeclaredCnName,
		DeclaredEnName:     *v.DeclaredEnName,
		DeclaredValueInUsd: *v.DeclaredValueInUsd,
		ProductWeight:      *v.ProductWeight,
		ProductLength:      *v.ProductLength,
		ProductWidth:       *v.ProductWidth,
		ProductHeight:      *v.ProductHeight,
		ProductBarcode:     *v.ProductBarcode,
		DeclaredValueInEur: *v.DeclaredValueInEur,
		RequiresShipping:   v.RequiresShipping,
		ExtOrderItemID:     v.ExtOrderItemID,
		ExtProductID:       v.ExtProductID,
		PlatformProductID:  v.PlatformProductID,
	}
	if v.Material != nil {
		res.Material = *v.Material
	}
	if v.Purpose != nil {
		res.Purpose = *v.Purpose
	}
	res.ProductAttributes = make([]string, len(v.ProductAttributes))
	for i, val := range v.ProductAttributes {
		res.ProductAttributes[i] = val
	}
	if v.Material == nil {
		res.Material = ""
	}
	if v.Purpose == nil {
		res.Purpose = ""
	}

	return res
}

// marshalOrderOutboundOrderRspDataToOutboundOrderRspDataResponseBody builds a
// value of type *OutboundOrderRspDataResponseBody from a value of type
// *order.OutboundOrderRspData.
func marshalOrderOutboundOrderRspDataToOutboundOrderRspDataResponseBody(v *order.OutboundOrderRspData) *OutboundOrderRspDataResponseBody {
	if v == nil {
		return nil
	}
	res := &OutboundOrderRspDataResponseBody{
		OrderNumber:    v.OrderNumber,
		TrackingNumber: v.TrackingNumber,
	}

	return res
}

// unmarshalAddressRequestBodyToOrderAddress builds a value of type
// *order.Address from a value of type *AddressRequestBody.
func unmarshalAddressRequestBodyToOrderAddress(v *AddressRequestBody) *order.Address {
	if v == nil {
		return nil
	}
	res := &order.Address{
		FirstName:         v.FirstName,
		LastName:          v.LastName,
		PhoneNumber:       v.PhoneNumber,
		CountryName:       v.CountryName,
		CountryCode:       v.CountryCode,
		StateName:         v.StateName,
		StateCode:         v.StateCode,
		Address1:          v.Address1,
		Address2:          v.Address2,
		CityName:          v.CityName,
		ZipCode:           v.ZipCode,
		Name:              v.Name,
		Company:           v.Company,
		Email:             v.Email,
		CertificateType:   v.CertificateType,
		CertificateCode:   v.CertificateCode,
		CertificatePeriod: v.CertificatePeriod,
	}

	return res
}

// unmarshalOutboundOrderItemUpdateRequestRequestBodyToOrderOutboundOrderItemUpdateRequest
// builds a value of type *order.OutboundOrderItemUpdateRequest from a value of
// type *OutboundOrderItemUpdateRequestRequestBody.
func unmarshalOutboundOrderItemUpdateRequestRequestBodyToOrderOutboundOrderItemUpdateRequest(v *OutboundOrderItemUpdateRequestRequestBody) *order.OutboundOrderItemUpdateRequest {
	if v == nil {
		return nil
	}
	res := &order.OutboundOrderItemUpdateRequest{
		OutboundOrderID:    v.OutboundOrderID,
		ProductSku:         v.ProductSku,
		ExtOrderItemID:     v.ExtOrderItemID,
		ProductName:        v.ProductName,
		ProductPrice:       v.ProductPrice,
		Barcode:            v.Barcode,
		Qty:                v.Qty,
		HsCode:             v.HsCode,
		DeclaredCnName:     v.DeclaredCnName,
		DeclaredEnName:     v.DeclaredEnName,
		DeclaredValueInUsd: v.DeclaredValueInUsd,
		DeclaredValueInEur: v.DeclaredValueInEur,
		ProductWeight:      v.ProductWeight,
		CustomerCode:       v.CustomerCode,
		Material:           v.Material,
		Purpose:            v.Purpose,
		RequiresShipping:   v.RequiresShipping,
		ProductLength:      v.ProductLength,
		ProductWidth:       v.ProductWidth,
		ProductHeight:      v.ProductHeight,
		ExtProductID:       v.ExtProductID,
		PlatformProductID:  v.PlatformProductID,
		ID:                 v.ID,
		Authorization:      v.Authorization,
		Token:              v.Token,
	}
	if v.ProductAttributes != nil {
		res.ProductAttributes = make([]string, len(v.ProductAttributes))
		for i, val := range v.ProductAttributes {
			res.ProductAttributes[i] = val
		}
	}
	if v.Images != nil {
		res.Images = make([]string, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = val
		}
	}

	return res
}

// unmarshalOutboundOrderUpdateRequestRequestBodyToOrderOutboundOrderUpdateRequest
// builds a value of type *order.OutboundOrderUpdateRequest from a value of
// type *OutboundOrderUpdateRequestRequestBody.
func unmarshalOutboundOrderUpdateRequestRequestBodyToOrderOutboundOrderUpdateRequest(v *OutboundOrderUpdateRequestRequestBody) *order.OutboundOrderUpdateRequest {
	if v == nil {
		return nil
	}
	res := &order.OutboundOrderUpdateRequest{
		ID:                        *v.ID,
		WarehouseID:               v.WarehouseID,
		Offline:                   v.Offline,
		EnablePrepayTariff:        v.EnablePrepayTariff,
		CustomerTariffNumberType:  v.CustomerTariffNumberType,
		CustomerTariffCountryCode: v.CustomerTariffCountryCode,
		CustomerTariffNumber:      v.CustomerTariffNumber,
		Description:               v.Description,
		Authorization:             v.Authorization,
		Token:                     v.Token,
	}
	if v.ReceiverInfo != nil {
		res.ReceiverInfo = unmarshalAddressRequestBodyToOrderAddress(v.ReceiverInfo)
	}
	if v.Items != nil {
		res.Items = make([]*order.OutboundOrderItemUpdateRequest, len(v.Items))
		for i, val := range v.Items {
			res.Items[i] = unmarshalOutboundOrderItemUpdateRequestRequestBodyToOrderOutboundOrderItemUpdateRequest(val)
		}
	}

	return res
}

// marshalOrderBatchUpdateResultToBatchUpdateResultResponseBody builds a value
// of type *BatchUpdateResultResponseBody from a value of type
// *order.BatchUpdateResult.
func marshalOrderBatchUpdateResultToBatchUpdateResultResponseBody(v *order.BatchUpdateResult) *BatchUpdateResultResponseBody {
	if v == nil {
		return nil
	}
	res := &BatchUpdateResultResponseBody{
		ID:      v.ID,
		Success: v.Success,
		Message: v.Message,
	}

	return res
}

// marshalOrderOrderInfoToOrderInfoResponseBody builds a value of type
// *OrderInfoResponseBody from a value of type *order.OrderInfo.
func marshalOrderOrderInfoToOrderInfoResponseBody(v *order.OrderInfo) *OrderInfoResponseBody {
	if v == nil {
		return nil
	}
	res := &OrderInfoResponseBody{}
	if v.List != nil {
		res.List = make([]*OrderDataResponseBody, len(v.List))
		for i, val := range v.List {
			res.List[i] = marshalOrderOrderDataToOrderDataResponseBody(val)
		}
	}
	if v.Meta != nil {
		res.Meta = marshalOrderMetaDataToMetaDataResponseBody(v.Meta)
	}

	return res
}

// marshalOrderOrderDataToOrderDataResponseBody builds a value of type
// *OrderDataResponseBody from a value of type *order.OrderData.
func marshalOrderOrderDataToOrderDataResponseBody(v *order.OrderData) *OrderDataResponseBody {
	res := &OrderDataResponseBody{
		CustomerOrderID: v.CustomerOrderID,
		Status:          v.Status,
		OrderNumber:     v.OrderNumber,
		TrackingNumber:  v.TrackingNumber,
		TrackingURL:     v.TrackingURL,
	}
	if v.Items != nil {
		res.Items = make([]*OutboundOrderItemResponseBody, len(v.Items))
		for i, val := range v.Items {
			res.Items[i] = marshalOrderOutboundOrderItemToOutboundOrderItemResponseBody(val)
		}
	}

	return res
}

// marshalOrderOutboundOrderItemToOutboundOrderItemResponseBody builds a value
// of type *OutboundOrderItemResponseBody from a value of type
// *order.OutboundOrderItem.
func marshalOrderOutboundOrderItemToOutboundOrderItemResponseBody(v *order.OutboundOrderItem) *OutboundOrderItemResponseBody {
	res := &OutboundOrderItemResponseBody{
		ProductName:        v.ProductName,
		ProductSku:         v.ProductSku,
		ProductPrice:       v.ProductPrice,
		Qty:                v.Qty,
		HsCode:             v.HsCode,
		DeclaredCnName:     v.DeclaredCnName,
		DeclaredEnName:     v.DeclaredEnName,
		DeclaredValueInUsd: v.DeclaredValueInUsd,
		ProductWeight:      v.ProductWeight,
		ProductLength:      v.ProductLength,
		ProductWidth:       v.ProductWidth,
		ProductHeight:      v.ProductHeight,
		ProductBarcode:     v.ProductBarcode,
		DeclaredValueInEur: v.DeclaredValueInEur,
		RequiresShipping:   v.RequiresShipping,
		ExtOrderItemID:     v.ExtOrderItemID,
		ExtProductID:       v.ExtProductID,
		PlatformProductID:  v.PlatformProductID,
		Material:           v.Material,
		Purpose:            v.Purpose,
	}
	if v.ProductAttributes != nil {
		res.ProductAttributes = make([]string, len(v.ProductAttributes))
		for i, val := range v.ProductAttributes {
			res.ProductAttributes[i] = val
		}
	}
	{
		var zero string
		if res.Material == zero {
			res.Material = ""
		}
	}
	{
		var zero string
		if res.Purpose == zero {
			res.Purpose = ""
		}
	}

	return res
}

// marshalOrderOrderListFiltersResultDataToOrderListFiltersResultDataResponseBody
// builds a value of type *OrderListFiltersResultDataResponseBody from a value
// of type *order.OrderListFiltersResultData.
func marshalOrderOrderListFiltersResultDataToOrderListFiltersResultDataResponseBody(v *order.OrderListFiltersResultData) *OrderListFiltersResultDataResponseBody {
	if v == nil {
		return nil
	}
	res := &OrderListFiltersResultDataResponseBody{}
	if v.KeywordsTypeList != nil {
		res.KeywordsTypeList = make([]*SelectOptionResponseBody, len(v.KeywordsTypeList))
		for i, val := range v.KeywordsTypeList {
			res.KeywordsTypeList[i] = marshalOrderSelectOptionToSelectOptionResponseBody(val)
		}
	}
	if v.PlatformList != nil {
		res.PlatformList = make([]*SelectOptionResponseBody, len(v.PlatformList))
		for i, val := range v.PlatformList {
			res.PlatformList[i] = marshalOrderSelectOptionToSelectOptionResponseBody(val)
		}
	}
	if v.StoreList != nil {
		res.StoreList = make([]*SelectOptionResponseBody, len(v.StoreList))
		for i, val := range v.StoreList {
			res.StoreList[i] = marshalOrderSelectOptionToSelectOptionResponseBody(val)
		}
	}
	if v.WarehouseList != nil {
		res.WarehouseList = make([]*SelectOptionResponseBody, len(v.WarehouseList))
		for i, val := range v.WarehouseList {
			res.WarehouseList[i] = marshalOrderSelectOptionToSelectOptionResponseBody(val)
		}
	}
	if v.CountryList != nil {
		res.CountryList = make([]*SelectOptionResponseBody, len(v.CountryList))
		for i, val := range v.CountryList {
			res.CountryList[i] = marshalOrderSelectOptionToSelectOptionResponseBody(val)
		}
	}

	return res
}

// marshalOrderSelectOptionToSelectOptionResponseBody builds a value of type
// *SelectOptionResponseBody from a value of type *order.SelectOption.
func marshalOrderSelectOptionToSelectOptionResponseBody(v *order.SelectOption) *SelectOptionResponseBody {
	if v == nil {
		return nil
	}
	res := &SelectOptionResponseBody{
		Value: v.Value,
		Label: v.Label,
	}
	{
		var zero string
		if res.Value == zero {
			res.Value = ""
		}
	}
	{
		var zero string
		if res.Label == zero {
			res.Label = ""
		}
	}

	return res
}

// marshalOrderOrderCountDataToOrderCountDataResponseBody builds a value of
// type *OrderCountDataResponseBody from a value of type *order.OrderCountData.
func marshalOrderOrderCountDataToOrderCountDataResponseBody(v *order.OrderCountData) *OrderCountDataResponseBody {
	if v == nil {
		return nil
	}
	res := &OrderCountDataResponseBody{
		Total:       v.Total,
		ReadyToShip: v.ReadyToShip,
		Pending:     v.Pending,
		Shipped:     v.Shipped,
		Cancelled:   v.Cancelled,
		Exception:   v.Exception,
	}

	return res
}

// marshalOrderGetOrderListDataToGetOrderListDataResponseBody builds a value of
// type *GetOrderListDataResponseBody from a value of type
// *order.GetOrderListData.
func marshalOrderGetOrderListDataToGetOrderListDataResponseBody(v *order.GetOrderListData) *GetOrderListDataResponseBody {
	if v == nil {
		return nil
	}
	res := &GetOrderListDataResponseBody{}
	if v.List != nil {
		res.List = make([]*ListItemResponseBody, len(v.List))
		for i, val := range v.List {
			res.List[i] = marshalOrderListItemToListItemResponseBody(val)
		}
	}
	if v.Mate != nil {
		res.Mate = marshalOrderMetaDataToMetaDataResponseBody(v.Mate)
	}

	return res
}

// marshalOrderListItemToListItemResponseBody builds a value of type
// *ListItemResponseBody from a value of type *order.ListItem.
func marshalOrderListItemToListItemResponseBody(v *order.ListItem) *ListItemResponseBody {
	if v == nil {
		return nil
	}
	res := &ListItemResponseBody{
		ID:                v.ID,
		PlatformOrderID:   v.PlatformOrderID,
		PlatformOrderNo:   v.PlatformOrderNo,
		Platform:          v.Platform,
		StoreID:           v.StoreID,
		StoreName:         v.StoreName,
		ChannelID:         v.ChannelID,
		ChannelName:       v.ChannelName,
		ChannelType:       v.ChannelType,
		ChannelTypeName:   v.ChannelTypeName,
		DeliveryCost:      v.DeliveryCost,
		NssTrackingNumber: v.NssTrackingNumber,
		WarehouseID:       v.WarehouseID,
		WarehouseName:     v.WarehouseName,
		Status:            v.Status,
		StatusName:        v.StatusName,
		CreatedAt:         v.CreatedAt,
		ShipDate:          v.ShipDate,
	}
	if v.ShippingInfo != nil {
		res.ShippingInfo = marshalOrderOrderListItemShipInfoToOrderListItemShipInfoResponseBody(v.ShippingInfo)
	}
	if v.Items != nil {
		res.Items = make([]*OrderItemResponseBody, len(v.Items))
		for i, val := range v.Items {
			res.Items[i] = marshalOrderOrderItemToOrderItemResponseBody(val)
		}
	}
	if v.ChannelOptions != nil {
		res.ChannelOptions = make([]*ChannelOptionResponseBody, len(v.ChannelOptions))
		for i, val := range v.ChannelOptions {
			res.ChannelOptions[i] = marshalOrderChannelOptionToChannelOptionResponseBody(val)
		}
	}
	if v.HoldReasons != nil {
		res.HoldReasons = make([]*HoldReasonResponseBody, len(v.HoldReasons))
		for i, val := range v.HoldReasons {
			res.HoldReasons[i] = marshalOrderHoldReasonToHoldReasonResponseBody(val)
		}
	}

	return res
}

// marshalOrderOrderListItemShipInfoToOrderListItemShipInfoResponseBody builds
// a value of type *OrderListItemShipInfoResponseBody from a value of type
// *order.OrderListItemShipInfo.
func marshalOrderOrderListItemShipInfoToOrderListItemShipInfoResponseBody(v *order.OrderListItemShipInfo) *OrderListItemShipInfoResponseBody {
	if v == nil {
		return nil
	}
	res := &OrderListItemShipInfoResponseBody{
		ShippingName:    v.ShippingName,
		ShippingCountry: v.ShippingCountry,
		ZipCode:         v.ZipCode,
	}

	return res
}

// marshalOrderOrderItemToOrderItemResponseBody builds a value of type
// *OrderItemResponseBody from a value of type *order.OrderItem.
func marshalOrderOrderItemToOrderItemResponseBody(v *order.OrderItem) *OrderItemResponseBody {
	if v == nil {
		return nil
	}
	res := &OrderItemResponseBody{
		Sku: v.Sku,
		Qty: v.Qty,
	}

	return res
}

// marshalOrderChannelOptionToChannelOptionResponseBody builds a value of type
// *ChannelOptionResponseBody from a value of type *order.ChannelOption.
func marshalOrderChannelOptionToChannelOptionResponseBody(v *order.ChannelOption) *ChannelOptionResponseBody {
	if v == nil {
		return nil
	}
	res := &ChannelOptionResponseBody{
		ID:              v.ID,
		ChannelName:     v.ChannelName,
		ShippingCost:    v.ShippingCost,
		ChannelTypeName: v.ChannelTypeName,
		MinNormalDays:   v.MinNormalDays,
		MaxNormalDays:   v.MaxNormalDays,
		ChargeWeight:    v.ChargeWeight,
		FuelFee:         v.FuelFee,
		MiscFee:         v.MiscFee,
		ProcessingFee:   v.ProcessingFee,
		TotalFee:        v.TotalFee,
	}

	return res
}

// marshalOrderHoldReasonToHoldReasonResponseBody builds a value of type
// *HoldReasonResponseBody from a value of type *order.HoldReason.
func marshalOrderHoldReasonToHoldReasonResponseBody(v *order.HoldReason) *HoldReasonResponseBody {
	if v == nil {
		return nil
	}
	res := &HoldReasonResponseBody{
		Type:   v.Type,
		Reason: v.Reason,
	}

	return res
}

// marshalOrderUploadOrdersDataToUploadOrdersDataResponseBody builds a value of
// type *UploadOrdersDataResponseBody from a value of type
// *order.UploadOrdersData.
func marshalOrderUploadOrdersDataToUploadOrdersDataResponseBody(v *order.UploadOrdersData) *UploadOrdersDataResponseBody {
	if v == nil {
		return nil
	}
	res := &UploadOrdersDataResponseBody{
		TotalCount:   v.TotalCount,
		SuccessCount: v.SuccessCount,
		FailCount:    v.FailCount,
		ResultFile:   v.ResultFile,
	}

	return res
}
