// Code generated by goa v3.6.2, DO NOT EDIT.
//
// user HTTP client CLI support package
//
// Command:
// $ goa gen goa/design -o ./

package client

import (
	"encoding/json"
	"fmt"
	user "goa/gen/user"
	"unicode/utf8"

	goa "goa.design/goa/v3/pkg"
)

// BuildUserSignupPayload builds the payload for the user user_signup endpoint
// from CLI flags.
func BuildUserSignupPayload(userUserSignupBody string) (*user.Signup, error) {
	var err error
	var body UserSignupRequestBody
	{
		err = json.Unmarshal([]byte(userUserSignupBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"concerns\": \"xxx\",\n      \"email\": \"xxx@nextsmartship.com\",\n      \"inviter_id\": 1,\n      \"password\": \"xxx\",\n      \"phone\": \"139xxxxxxxx\",\n      \"platform\": \"xxx\",\n      \"source\": \"shopify\",\n      \"store_code\": \"xxx\",\n      \"user_name\": \"john\",\n      \"website\": \"xxx\"\n   }'")
		}
		if body.InviterID != nil {
			if *body.InviterID < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.inviter_id", *body.InviterID, 1, true))
			}
		}
		if body.StoreCode != nil {
			if utf8.RuneCountInString(*body.StoreCode) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.store_code", *body.StoreCode, utf8.RuneCountInString(*body.StoreCode), 1, true))
			}
		}
		if body.Website != nil {
			if utf8.RuneCountInString(*body.Website) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.website", *body.Website, utf8.RuneCountInString(*body.Website), 1, true))
			}
		}
		if body.Platform != nil {
			if utf8.RuneCountInString(*body.Platform) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.platform", *body.Platform, utf8.RuneCountInString(*body.Platform), 1, true))
			}
		}
		if body.Concerns != nil {
			if utf8.RuneCountInString(*body.Concerns) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.concerns", *body.Concerns, utf8.RuneCountInString(*body.Concerns), 1, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &user.Signup{
		Email:     body.Email,
		Password:  body.Password,
		UserName:  body.UserName,
		Phone:     body.Phone,
		Source:    body.Source,
		InviterID: body.InviterID,
		StoreCode: body.StoreCode,
		Website:   body.Website,
		Platform:  body.Platform,
		Concerns:  body.Concerns,
	}

	return v, nil
}

// BuildUserLoginPayload builds the payload for the user user_login endpoint
// from CLI flags.
func BuildUserLoginPayload(userUserLoginBody string) (*user.Login, error) {
	var err error
	var body UserLoginRequestBody
	{
		err = json.Unmarshal([]byte(userUserLoginBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"xxx@nextsmartship.com\",\n      \"password\": \"xxx\",\n      \"store_code\": \"xxx\"\n   }'")
		}
		if body.StoreCode != nil {
			if utf8.RuneCountInString(*body.StoreCode) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.store_code", *body.StoreCode, utf8.RuneCountInString(*body.StoreCode), 1, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &user.Login{
		Email:     body.Email,
		Password:  body.Password,
		StoreCode: body.StoreCode,
	}

	return v, nil
}

// BuildUserModifyPasswordPayload builds the payload for the user
// user_modify_password endpoint from CLI flags.
func BuildUserModifyPasswordPayload(userUserModifyPasswordBody string, userUserModifyPasswordAuthorization string, userUserModifyPasswordToken string) (*user.ModifyPassword, error) {
	var err error
	var body UserModifyPasswordRequestBody
	{
		err = json.Unmarshal([]byte(userUserModifyPasswordBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"xxx@nextsmartship.com\",\n      \"old_password\": \"xxx\",\n      \"password\": \"xxx\"\n   }'")
		}
	}
	var authorization *string
	{
		if userUserModifyPasswordAuthorization != "" {
			authorization = &userUserModifyPasswordAuthorization
		}
	}
	var token *string
	{
		if userUserModifyPasswordToken != "" {
			token = &userUserModifyPasswordToken
		}
	}
	v := &user.ModifyPassword{
		Email:       body.Email,
		Password:    body.Password,
		OldPassword: body.OldPassword,
	}
	v.Authorization = authorization
	v.Token = token

	return v, nil
}

// BuildUserForgetPasswordPayload builds the payload for the user
// user_forget_password endpoint from CLI flags.
func BuildUserForgetPasswordPayload(userUserForgetPasswordBody string) (*user.ForgetPassword, error) {
	var err error
	var body UserForgetPasswordRequestBody
	{
		err = json.Unmarshal([]byte(userUserForgetPasswordBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"action\": \"xxx\",\n      \"code\": \"xxx\",\n      \"email\": \"xxx@nextsmartship.com\",\n      \"password\": \"xxx\"\n   }'")
		}
		if body.Action != nil {
			if utf8.RuneCountInString(*body.Action) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.action", *body.Action, utf8.RuneCountInString(*body.Action), 1, true))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	v := &user.ForgetPassword{
		Email:    body.Email,
		Password: body.Password,
		Code:     body.Code,
		Action:   body.Action,
	}

	return v, nil
}

// BuildUserValidatePayload builds the payload for the user user_validate
// endpoint from CLI flags.
func BuildUserValidatePayload(userUserValidateBody string) (*user.ValidateEmail, error) {
	var err error
	var body UserValidateRequestBody
	{
		err = json.Unmarshal([]byte(userUserValidateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"email\": \"xxx@nextsmartship.com\"\n   }'")
		}
	}
	v := &user.ValidateEmail{
		Email: body.Email,
	}

	return v, nil
}

// BuildUserLogoutPayload builds the payload for the user user_logout endpoint
// from CLI flags.
func BuildUserLogoutPayload(userUserLogoutAuthorization string, userUserLogoutToken string) (*user.Logout, error) {
	var authorization *string
	{
		if userUserLogoutAuthorization != "" {
			authorization = &userUserLogoutAuthorization
		}
	}
	var token *string
	{
		if userUserLogoutToken != "" {
			token = &userUserLogoutToken
		}
	}
	v := &user.Logout{}
	v.Authorization = authorization
	v.Token = token

	return v, nil
}

// BuildGetUserInfoPayload builds the payload for the user get_user_info
// endpoint from CLI flags.
func BuildGetUserInfoPayload(userGetUserInfoAuthorization string, userGetUserInfoToken string) (*user.AuthToken, error) {
	var authorization *string
	{
		if userGetUserInfoAuthorization != "" {
			authorization = &userGetUserInfoAuthorization
		}
	}
	var token *string
	{
		if userGetUserInfoToken != "" {
			token = &userGetUserInfoToken
		}
	}
	v := &user.AuthToken{}
	v.Authorization = authorization
	v.Token = token

	return v, nil
}

// BuildUpdateUserInfoPayload builds the payload for the user update_user_info
// endpoint from CLI flags.
func BuildUpdateUserInfoPayload(userUpdateUserInfoBody string, userUpdateUserInfoAuthorization string, userUpdateUserInfoToken string) (*user.UserInfo, error) {
	var err error
	var body UpdateUserInfoRequestBody
	{
		err = json.Unmarshal([]byte(userUpdateUserInfoBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"user_name\": \"Rerum voluptatibus.\"\n   }'")
		}
	}
	var authorization *string
	{
		if userUpdateUserInfoAuthorization != "" {
			authorization = &userUpdateUserInfoAuthorization
		}
	}
	var token *string
	{
		if userUpdateUserInfoToken != "" {
			token = &userUpdateUserInfoToken
		}
	}
	v := &user.UserInfo{
		UserName: body.UserName,
	}
	v.Authorization = authorization
	v.Token = token

	return v, nil
}

// BuildPermissionsPayload builds the payload for the user permissions endpoint
// from CLI flags.
func BuildPermissionsPayload(userPermissionsAuthorization string, userPermissionsToken string) (*user.AuthToken, error) {
	var authorization *string
	{
		if userPermissionsAuthorization != "" {
			authorization = &userPermissionsAuthorization
		}
	}
	var token *string
	{
		if userPermissionsToken != "" {
			token = &userPermissionsToken
		}
	}
	v := &user.AuthToken{}
	v.Authorization = authorization
	v.Token = token

	return v, nil
}
