// Code generated by goa v3.6.2, DO NOT EDIT.
//
// platform_product HTTP client CLI support package
//
// Command:
// $ goa gen goa/design -o ./

package client

import (
	"encoding/json"
	"fmt"
	platformproduct "goa/gen/platform_product"
	"strconv"

	goa "goa.design/goa/v3/pkg"
)

// BuildPlatformProductPayload builds the payload for the platform_product
// platform_product endpoint from CLI flags.
func BuildPlatformProductPayload(platformProductPlatformProductPlatformStatus string, platformProductPlatformProductName string, platformProductPlatformProductPageSize string, platformProductPlatformProductCurrent string, platformProductPlatformProductID string, platformProductPlatformProductListingSku string, platformProductPlatformProductSku string, platformProductPlatformProductIsMapping string, platformProductPlatformProductAuthorization string, platformProductPlatformProductToken string) (*platformproduct.GetListing, error) {
	var err error
	var platformStatus *int
	{
		if platformProductPlatformProductPlatformStatus != "" {
			var v int64
			v, err = strconv.ParseInt(platformProductPlatformProductPlatformStatus, 10, 64)
			val := int(v)
			platformStatus = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for platformStatus, must be INT")
			}
		}
	}
	var name *string
	{
		if platformProductPlatformProductName != "" {
			name = &platformProductPlatformProductName
		}
	}
	var pageSize *int
	{
		if platformProductPlatformProductPageSize != "" {
			var v int64
			v, err = strconv.ParseInt(platformProductPlatformProductPageSize, 10, 64)
			val := int(v)
			pageSize = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for pageSize, must be INT")
			}
			if pageSize != nil {
				if !(*pageSize == 10 || *pageSize == 20 || *pageSize == 50 || *pageSize == 100) {
					err = goa.MergeErrors(err, goa.InvalidEnumValueError("pageSize", *pageSize, []interface{}{10, 20, 50, 100}))
				}
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var current *int
	{
		if platformProductPlatformProductCurrent != "" {
			var v int64
			v, err = strconv.ParseInt(platformProductPlatformProductCurrent, 10, 64)
			val := int(v)
			current = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for current, must be INT")
			}
			if current != nil {
				if *current < 1 {
					err = goa.MergeErrors(err, goa.InvalidRangeError("current", *current, 1, true))
				}
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var id *int32
	{
		if platformProductPlatformProductID != "" {
			var v int64
			v, err = strconv.ParseInt(platformProductPlatformProductID, 10, 32)
			val := int32(v)
			id = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for id, must be INT32")
			}
		}
	}
	var listingSku *string
	{
		if platformProductPlatformProductListingSku != "" {
			listingSku = &platformProductPlatformProductListingSku
		}
	}
	var sku *string
	{
		if platformProductPlatformProductSku != "" {
			sku = &platformProductPlatformProductSku
		}
	}
	var isMapping *int
	{
		if platformProductPlatformProductIsMapping != "" {
			var v int64
			v, err = strconv.ParseInt(platformProductPlatformProductIsMapping, 10, 64)
			val := int(v)
			isMapping = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for isMapping, must be INT")
			}
		}
	}
	var authorization *string
	{
		if platformProductPlatformProductAuthorization != "" {
			authorization = &platformProductPlatformProductAuthorization
		}
	}
	var token *string
	{
		if platformProductPlatformProductToken != "" {
			token = &platformProductPlatformProductToken
		}
	}
	v := &platformproduct.GetListing{}
	v.PlatformStatus = platformStatus
	v.Name = name
	v.PageSize = pageSize
	v.Current = current
	v.ID = id
	v.ListingSku = listingSku
	v.Sku = sku
	v.IsMapping = isMapping
	v.Authorization = authorization
	v.Token = token

	return v, nil
}

// BuildConvertPayload builds the payload for the platform_product convert
// endpoint from CLI flags.
func BuildConvertPayload(platformProductConvertBody string, platformProductConvertAuthorization string, platformProductConvertToken string) (*platformproduct.ConvertPlatformProductsReq, error) {
	var err error
	var body ConvertRequestBody
	{
		err = json.Unmarshal([]byte(platformProductConvertBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"platform_product_ids\": [\n         1\n      ]\n   }'")
		}
		if body.PlatformProductIds == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("platform_product_ids", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var authorization *string
	{
		if platformProductConvertAuthorization != "" {
			authorization = &platformProductConvertAuthorization
		}
	}
	var token *string
	{
		if platformProductConvertToken != "" {
			token = &platformProductConvertToken
		}
	}
	v := &platformproduct.ConvertPlatformProductsReq{}
	if body.PlatformProductIds != nil {
		v.PlatformProductIds = make([]int32, len(body.PlatformProductIds))
		for i, val := range body.PlatformProductIds {
			v.PlatformProductIds[i] = val
		}
	}
	v.Authorization = authorization
	v.Token = token

	return v, nil
}

// BuildMappingsPayload builds the payload for the platform_product mappings
// endpoint from CLI flags.
func BuildMappingsPayload(platformProductMappingsBody string, platformProductMappingsAuthorization string, platformProductMappingsToken string) (*platformproduct.UpdateMappingsReq, error) {
	var err error
	var body MappingsRequestBody
	{
		err = json.Unmarshal([]byte(platformProductMappingsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"platform_product_ids\": [\n         1\n      ],\n      \"products\": [\n         {\n            \"product_id\": 1,\n            \"qty\": 1\n         },\n         {\n            \"product_id\": 1,\n            \"qty\": 1\n         }\n      ]\n   }'")
		}
		if body.PlatformProductIds == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("platform_product_ids", "body"))
		}
		if body.Products == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("products", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var authorization *string
	{
		if platformProductMappingsAuthorization != "" {
			authorization = &platformProductMappingsAuthorization
		}
	}
	var token *string
	{
		if platformProductMappingsToken != "" {
			token = &platformProductMappingsToken
		}
	}
	v := &platformproduct.UpdateMappingsReq{}
	if body.PlatformProductIds != nil {
		v.PlatformProductIds = make([]int32, len(body.PlatformProductIds))
		for i, val := range body.PlatformProductIds {
			v.PlatformProductIds[i] = val
		}
	}
	if body.Products != nil {
		v.Products = make([]*platformproduct.UpdateMappingsProduct, len(body.Products))
		for i, val := range body.Products {
			v.Products[i] = marshalUpdateMappingsProductRequestBodyToPlatformproductUpdateMappingsProduct(val)
		}
	}
	v.Authorization = authorization
	v.Token = token

	return v, nil
}
